### 1. 什么是事件委托，为什么要用事件委托？

#### 1.1 定义

是 `JavaScript` 中的一**种事件处理机制**，它允许开发者**将事件监听器绑定到父元素**，而不是每个子元素。当某个子元素触发事件时，事件会 **冒泡** 到父元素，由父元素来处理该事件。

> `event.target ` 表示实际触发事件的元素

#### 1.2 优势

- **性能优化**：对于具有大量子元素的父元素，逐个为每个子元素绑定事件监听器会耗费大量内存，而**事件委托只需要为父元素绑定一次事件监听器，从而节省资源，提升页面性能**
- **动态元素处理**：事件委托可以处理动态生成的子元素，无需重新绑定事件监听器
- **代码简洁**：减少了重复的事件绑定代码，提高了代码的可维护性

```javascript
<ul id="dynamicList">
  <li>Item A</li>
  <li>Item B</li>
  <li>Item C</li>
</ul>

<button id="addItem">Add Item</button>

<script>
const ul = document.getElementById('dynamicList');
const addItemButton = document.getElementById('addItem');

// 使用事件委托绑定点击事件
ul.addEventListener('click', (event) => {
  if (event.target.tagName === 'LI') {
    // 获取每个 li 的索引
    console.log(`Clicked: ${event.target.id}`);
  }
});

// 动态添加新列表项
addItemButton.addEventListener('click', () => {
  const newItem = document.createElement('li');
  newItem.textContent = `Item ${ul.children.length + 1}`;
  ul.appendChild(newItem);
});

</script>
```



### 2. 一个父元素有两个子div，左 div 固定宽度 100px，如何让右侧 div 自适应父div的剩余宽度？

#### 2.1 使用 Flex 布局

```javascript
<div class="parent">
  <div class="left">左侧固定宽度</div>
  <div class="right">右侧自适应宽度</div>
</div>

<style>
.parent {
  display: flex;
}
.left {
  width: 100px;
  background: lightblue;
}
.right {
  flex: 1; /* 占据剩余所有空间 */
  background: lightgreen;
}
</style>
```

#### 2.2 使用 Grid 布局

```javascript
<div class="parent">
  <div class="left">左侧固定宽度</div>
  <div class="right">右侧自适应宽度</div>
</div>

<style>
.parent {
  display: grid;
  grid-template-columns: 100px 1fr; /* 第一列100px，第二列剩余空间 */
}
.left {
  background: lightblue;
}
.right {
  background: lightgreen;
}
</style>
```

#### 2.3 使用浮动 + margin

```javascript
<div class="parent">
  <div class="left">左侧固定宽度</div>
  <div class="right">右侧自适应宽度</div>
</div>

<style>
.left {
  float: left;
  width: 100px;
  background: lightblue;
}
.right {
  margin-left: 100px; /* 等于左侧div的宽度 */
  background: lightgreen;
}
</style>
```

#### 2.4 使用 calc 计算

```javascript
<div class="parent">
  <div class="left">左侧固定宽度</div>
  <div class="right">右侧自适应宽度</div>
</div>

<style>
.parent {
  width: 100%;
}
.left {
  float: left;
  width: 100px;
  background: lightblue;
}
.right {
  width: calc(100% - 100px); /* 计算剩余宽度 */
  float: left;
  background: lightgreen;
}
</style>
```



### 4. `npm run build` 打包后的 `dist` 文件夹下有什么

- **`index.html`**：项目的**入口文件**，包含基本的 `HTML` 结构和静态资源引用
- **`assets` 文件夹**：存放存放**压缩后的 `Javascript` 和 `CSS` 文件和图片、字体等静态资源**
- **`favicon.ico`**：网站图标



### 5.Echarts使用



### 6. HTTP状态码

| 状态码  |       类别       |         名称          |               描述               |
| :-----: | :--------------: | :-------------------: | :------------------------------: |
| **200** |    2xx (成功)    |          OK           |     请求成功，返回请求的数据     |
| **201** |    2xx (成功)    |        Created        | 请求成功，并在服务器创建了新资源 |
| **202** |    2xx (成功)    |       Accepted        |    请求已接受，但尚未处理完成    |
| **204** |    2xx (成功)    |      No Content       |      请求成功，但无返回内容      |
| **301** |   3xx (重定向)   |   Moved Permanently   |      资源已永久移动到新 URL      |
| **302** |   3xx (重定向)   |         Found         |       资源临时移动到新 URL       |
| **304** |   3xx (重定向)   |     Not Modified      |    资源未修改，可使用缓存版本    |
| **400** | 4xx (客户端错误) |      Bad Request      |   请求语法错误，服务器无法理解   |
| **401** | 4xx (客户端错误) |     Unauthorized      |         请求需要身份验证         |
| **403** | 4xx (客户端错误) |       Forbidden       |  服务器拒绝执行请求（权限不足）  |
| **404** | 4xx (客户端错误) |       Not Found       |         请求的资源不存在         |
| **405** | 4xx (客户端错误) |  Method Not Allowed   |  请求方法（GET/POST等）不被允许  |
| **408** | 4xx (客户端错误) |    Request Timeout    |             请求超时             |
| **429** | 4xx (客户端错误) |   Too Many Requests   |       请求过于频繁（限流）       |
| **500** | 5xx (服务器错误) | Internal Server Error |          服务器内部错误          |
| **502** | 5xx (服务器错误) |      Bad Gateway      |   网关或代理服务器收到无效响应   |
| **503** | 5xx (服务器错误) |  Service Unavailable  |  服务器暂时不可用（过载或维护）  |
| **504** | 5xx (服务器错误) |    Gateway Timeout    |       网关或代理服务器超时       |



### 7. js 模块化

#### 7.1 什么是模块化

模块化是一种软件**设计方法**，指将程序拆分为多个功能单一、相对独立的模块

![img](https://i-blog.csdnimg.cn/img_convert/5caa82c69b4b6fe7da201b8027166bca.webp?x-oss-process=image/format,png)

#### 7.2 **CommonJS **：Node.js 的模块规范

==不适用于浏览器，浏览器需要打包工具（如 Webpack）将模块转为可执行代码==

```javascript
// greet.js
module.exports = function() {
  console.log('Hello from CommonJS!');
};
 
// app.js
const greet = require('./greet');
greet();
```

#### 7.3 **AMD 异步模块定义**：专为浏览器端设计的模块规范

```javascript
// 定义模块
define('greet', [], function() {
  return function() {
    console.log('Hello from AMD!');
  };
});
 
// 使用模块
require(['greet'], function(greet) {
  greet();
});
```

#### 7.4 **ES Module**：现代前端开发的主流模块方案

```javascript
// 导出
export function greet() {
  console.log('Hello from ES6!');
}

// 引入
import { greet } from './greet.js';

// 默认导出
export default function greet() {
  console.log('Hello from default export!');
}
```



### 8. ==请求的过程==

![img](https://i-blog.csdnimg.cn/img_convert/72665a8c5969769f2c50be4af097ea51.png)

#### Q：为什么需要三次握手，两次不行吗？

A：**三次握手、四次挥手 的目的就是为了确认双方是否可接受可发送数据**。如果改为两次握手，假如客户端第一次发送了建立连接的消息（第一次握手），由于网络卡顿了或其他原因，没有及时传达到服务端，过了一会儿时间，客户端迟迟未收到服务端的确认消息，便取消了这次信息传输，但是一段时间后，服务端终于接收到了此条消息，于是向客户端发送可建立连接的消息（第二次握手），如果只有两次握手，那么此时双方的连接就建立了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/eda0845d7201f1c3ef7315723be9b7cf.png)



### 10. BOM 和 DOM

#### 10.1 BOM：浏览器对象模型，用于访问和操作浏览器窗口本身

- ##### window对象：BOM的顶层对象，代表浏览器窗口

```javascript
// 获取窗口尺寸
const windowWidth = window.innerWidth;
const windowHeight = window.innerHeight;

// 打开新窗口
const newWindow = window.open('https://example.com', '_blank', 'width=600,height=400');

// 定时器
const timer = setTimeout(() => {
    console.log('2秒后执行');
}, 2000);

// 清除定时器
clearTimeout(timer);
```

- #####  location对象：提供当前窗口加载文档的信息和控制导航功能

```javascript
// 获取当前URL信息
console.log(location.href);     // 完整URL
console.log(location.protocol); // 协议（http:或https:）
console.log(location.host);     // 主机名和端口
console.log(location.pathname); // 路径部分

// 页面跳转
location.assign('https://newpage.com');
location.replace('https://newpage.com'); // 不会在历史记录中留下记录
location.reload(); // 重新加载当前页面
```

- ##### navigator对象：提供浏览器和操作系统相关信息

```javascript
// 浏览器信息
console.log(navigator.userAgent); // 用户代理字符串
console.log(navigator.platform);  // 操作系统平台
console.log(navigator.language);  // 浏览器语言
```

- #####  screen对象：提供用户屏幕的信息

```javascript
console.log(screen.width);    // 屏幕宽度
console.log(screen.height);   // 屏幕高度
console.log(screen.availWidth); // 可用宽度
console.log(screen.colorDepth); // 颜色深度
```

- ##### history对象：提供浏览器历史记录的操作

```javascript
// 历史记录导航
history.back();     // 等同于点击后退按钮
history.forward(); // 等同于点击前进按钮
history.go(-2);    // 后退两页

// 添加历史记录
history.pushState({page: 1}, "title 1", "?page=1");
history.replaceState({page: 2}, "title 2", "?page=2")
```

#### 10.2 DOM：文档对象模型，将 HTML 表示为树形结构的 API

- **Document**：整个文档，是 DOM 树的根节点。
  - **Element**：文档中的元素，如 `<p> <div>` 等。Element 对象可以包含其他 Element 对象、Text 对象和 Comment 对象作为子节点。
    - **Attribute**：元素的属性，如 class、id、src 等，通常附属于 Element 对象。
    - **Text**：元素节点或属性节点中的文本内容。
    - **Comment**：文档中的注释。



### 11. HTTP 和 HTTPS

**HTTP**：**超文本传输协议**，默认端口是‌ **80**。
**HTTPS**：**超文本传输安全协议**，其实就是在 HTTP 的基础上**加上了 `TLS/SSL` 协议**，默认端口是‌**443**。



### 12. TCP 和 UDP 协议

#### 12.1 TCP 协议：面向连接的、可靠的传输协议

- **面向连接**：TCP 通过**"三次握手"过程建立连接**，确保通信双方都准备好传输数据；通过**"四次挥手"过程连接终止**，确保双方都完全关闭连接
- **数据完整性保障**：TCP 会**对数据报文执行校验和计算**，接收方验证校验和以确保数据未被篡改或损坏
- **顺序控制**：TCP为每个数据片段分配序号，接收方按序号重组数据，即使网络传输导致数据包乱序到达，最终也能还原出正确的数据顺序
- **流量与拥塞控制**：TCP能动态调整发送速率，根据网络状况使用滑动窗口等技术避免网络拥塞
- **适用场景**：
  - **需要高可靠性的应用**：如网页浏览(HTTP)、文件传输(FTP)、电子邮件(SMTP/POP3)
  - **大数据量传输**：如软件下载、数据库同步
  - **需要严格顺序的应用**：如远程终端访问(SSH)、金融交易

#### 12.2 UDP 协议：无连接的、不可靠的传输协议

- **无连接**：UDP 不需要预先建立连接，**应用程序可以直接开始发送数据**，这使得**UDP的初始==延迟极低==**
- **面向报文**：UDP不对应用层交下来的数据进行任何处理，保留报文边界，直接添加首部后就交给IP层
- **适用场景**：
  - **实时应用**：如视频会议、在线游戏等
  - **广播/多播**：UDP天然支持一对多通信模式，适合视频直播等场景
  - **简单查询响应**：如DNS查询，通常一个请求对应一个响应，不需要复杂连接

#### 

### 13. 场景问答

#### 13.1 多个路由复用同一个组件会发生什么

- **数据污染**：组件的内部状态（如 `data`、`ref`值）在不同页面实例间共享，导致页面 A 的操作影响页面 B 的显示
- **页面不刷新**：复用组件时，Vue 会**复用实例而非重新创建**，导致 `created`等钩子只执行一次
-  **副作用累积**：未及时清理的副作用（如定时器、全局事件监听）在页面切换后持续存在

#### 13.2 多个地方同时修改同一个数据,如何判断是谁修改的,如何确保数据一致性

##### 13.2.1 问题核心

- **数据来源不明确**：无法直接追踪是哪个组件触发了数据修改。
- **竞争条件**：异步操作（如 API 请求）可能导致后发操作覆盖先发操作的结果。
- **一致性破坏**：多个写入源使数据状态难以预测。

##### 13.2.2 解决方案



### 14. Vueuse 的常用 hooks



### 15. SPA 如何进行 SEO 优化

- **使用 SSR 服务器端渲染**：`React` 的 `Next.js`, `Vue` 的 `Nuxt.js`
- **预渲染**：

- #####  ==优化元标签==:

  - **标题标签（Title Tag）**包含关键词

  ```javascript
  <title>产品名称 - 公司名称</title>
  ```

  - **描述标签（Meta Description）**：编写吸引人的描述，包含关键词，以提高在搜索结果中的点击率

  ```javascript
  <meta name="description" content="这是一个关于产品的详细描述，包含了产品的特点和优势。">
  ```

- #####  优化 URL 和路由：在路由中添意义明确且间接的关键词
