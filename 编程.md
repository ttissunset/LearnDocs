### 1. 介绍防抖节流原理、区别以及应用，并用JavaScript进行实现

#### 节流：固定时间间隔内，无论触发多少次事件，都==只执行一次==

- 使用场景：
  -  **拖拽**场景：防止高频次触发位置改变
  - **缩放**场景：如监控浏览器 resize

```js
/**  
* @fn: 要被节流的函数
* @delay：固定间隔时间，这里设置默认为 300ms
*/
function throttle(fn, delay = 300){
    // flag 为函数是否可以执行的标志
    let flag = true
    
    function throttled(...args){
        // 如果 flag 为 false 表示函数不可执行，直接return
        if(!flag) return
        // flag 为 true 表示函数可以执行
        // 改变 flag 标志，表示函数在执行中，不可被重复执行
        flag = false
        // 保存 this 指向
        let context = this 
        // 设置定时器，保证函数在 delay 内只会执行一次
        setTimeout(()=>{
            // 确保回调函数 fn 能访问正确的 this 上下文
            fn.apply(context, args)
            // 函数执行完毕后，重新修改 flag 标志，表示可以执行下一次函数调用
            flag = true
        }, delay)
    }
    
    return throttled 
}
```

#### 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时 --> 确保==只执行最后一次==

- 使用场景：
  - 提交**按钮**：防止多次触发按钮提交时间
  - **搜索框**联想：防止每次输入都发送请求，限制发送最后一次请求

```js
function debounce(fn, delay = 300) {
    // 是否存在计时器的标志
    let timer = null
    
    function debounced(...args){
        // 保存 this 指向
        let context = this 
        // 初始时清除计时器
        clearTimeout(timer)
        // 设置新计时器，延迟执行
        timer =  setTimeout(() => {
            // 确保回调函数 fn 能访问正确的 this 上下文
            fn.apply(context, args)
        }, delay)
    }
    
    return debounced;
}
```



### 2. 实现 `instanceof` 函数

`myInstanceof(left, right)` 运算符接收两个参数，用于检测  ==right 是否存在于 left 的**原型链**上==。**`instanceof` 只能用于检测引用数据类型`(Object/Array/Function)`**。

> 注意：`typeof` 检测数组也会返回 `object` 

```javascript
function myInstanceof(left, right) {
    // 如果被检测对象为空或者不为对象、函数，则直接返回 false
    if(left === null || (typeof left !== 'object' && typeof left !== 'function')) return false
    
    // 获取 left 的对象原型
    let proto = Object.getPrototypeOf(left)
    
    // 如果 proto 为 null 则表示已经查找到原型链顶端了，则直接返回 false
    while(proto !== null){
        // 如果 left 的原型对象和 right 的原型对象相同，则表示 left 为 right 的实例，返回 true
        if(proto === right.prototype) return true
        // 如果前面都不匹配，则继续沿着原型链查找，直到查找到原型链顶端
        proto = Object.getPrototypeOf(proto)
    }
    return false
}
```



### 3. 实现 add(1)(2)(3)

思路：**函数柯理化**

> **接受多个参数的==函数==转变为接受一个单一参数的函数，并且返回==接受余下的参数且返回结果的新函数==**
>
> ==柯里化函数的设计要求**用空调用() 触发最终执行**（即告诉函数"参数收集完毕，现在执行"）==

```javascript
// 1. 暴力解法 --> 缺点：多层嵌套，且只能接受三个参数
function add (a) {
	return function (b) {
		return function (c) {
		    return a + b + c;
		}
	}
}

// 2. 函数柯理化 --> 将所有参数收集到一个数组中，然后通过 reduce 累加即可
// 2.1 收集所有参数
/**
* @fn: 需要珂理化的函数
* @args：已收集的参数数组
*/
function currying(fn, args = []) {
    return function temp(...innerArgs) {
        // 如果有传入参数时
        if (innerArgs.length > 0) {
            // 收集后面传入的参数
            args = [...args, ...innerArgs];
            // 返回函数本身以继续接收更多参数
            return temp;
        } else {
            // 确保回调函数 fn 能访问正确的 this 上下文，并接收参数数组 args
            const val = fn.apply(this, args);
            // 清空参数数组，为了保证下次执行函数可以继续迭代
            args = [];
            // 返回函数执行结果
            return val;
        }
    }
}
// 2.2 求和函数
const add = (...args) => args.reduce((a, b) => a + b);
// addCurry 传入的参数会被 ...innerArgs 接收
let addCurry = currying(add)

console.log(addCurry(1)(2)(3)(4, 5)())  //15
console.log(addCurry(1)(2)(3, 4, 5)())  //15
console.log(addCurry(1)(2, 3, 4, 5)())  //15
```



### 4. 写出下列代码执行结果

```javascript
for(var i = 0; i < 5; i++){
    setTimeout(function(){
        console.log(i++)
    }, 4000)
}
console.log(i)
// 输出：5 5 6 7 8 9 
/**
* 解析:
* setTimeout 是一个宏任务，会被加入到宏任务队列当中，当所有的同步任务和微任务执行完毕才会被执行;
* 因此在宏任务队列中会加入五个 i++ 等待被执行，又由于 var 声明的变量存在变量提升，最后访问的都是同一个 var 变量;
* 当跳出 for 循环时 i = 5，所以 console.log(i) 会输出5;
* 当所有任务都执行完毕的 4000ms 后，宏任务中的代码会被依次执行，因为所有的 setTimeout 函数都共享同一个变量 i = 5;
* 又因为 i++ 会先输出 i 的值再加一，故 console.log(i++) 依次输出 5 6 7 8 9 
*/
```

##### 如何确保 for 循环中正确输出 0 1 2 3 4 ？

我们可以通过**立即执行函数 + 闭包**的方式来解决问题。

```javascript
for(var i = 0; i < 5; i++){
    (function(x){
        setTimeout(function(){
        	console.log(x++)
    	}, 4000)
    })(i)
}
console.log(i)
// 输出：5 0 1 2 3 4
/**
* 解析:
* 每个立即执行函数都会创建一个闭包，五个立即执行函数会分别创建单独的作用域并保存传入的参数 i；
* 所以每个 setTimeout 函数都会使用当前函数作用域中所保留的变量 x (0, 1, 2, 3, 4);
* 由于 x++ 会先输出 x 的值再加一，故 console.log(x++) 依次输出 0 1 2 3 4
*/
```



### 5. 编写一段代码实现一个数组方法 `array.last()` ，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 `-1` 。

思路：**Array 的 prototype 中的 this 指向当前的数组实例**，因此我们可以从 this 中获取 length 属性。 如果 `(!this.length) === true` 则代表 数组为空，则应该返回 -1 如果不为空，则直接返回数组下标为 length-1的元素即可

```javascript
// 将该方法大挂载到 Array 的原型上，就能满足任何数组都能调用该方法
Array.prototype.last = function() {
    return this.length ? this[this.length-1]: -1
};
```



### 6. 写出下列代码执行结果并解释原因

> 考察：立即执行函数、变量提升

```javascript
(function () {
  var a = (b = 5);
})();
console.log(b); // 5
console.log(a); // Uncaught ReferenceError: a is not defined

/**
* 解释：
* var a = (b = 5) 等价于：
* b = 5;
* var a = b;
* 由于 b 没有使用 var/let/const 进行声明，所以会隐式的被创建为全局变量挂载到 window 下，因此输出 b = 5；
* 而 a 在函数内通过 var 声明具有函数作用域，只在函数内部生效，故在函数外输出报错 a is not defined。
* 注意：如果在严格模式下，b = 5 会报错 Uncaught ReferenceError: b is not defined；我们需要使用 window.b=5 进行声明
*/
```



### 7.  写出下列代码执行结果并解释原因

> 考察：原型链

```javascript
var company = {
  address: "beijing",
};

var kiri = Object.create(company);

delete kiri.address;
console.log(kiri.address); // “beijing”

/**
* 解释：
* var kiri = Object.create(company) 创建了新对象 kiri，同时将其原型 __proto__ 指向 company
* 由于 kiri 自身是没有 address 属性的，通过从原型链继承了 company 的 address 属性
* 所以直接 delete kiri.address 是无效的，默认操作失败，而 console.log(kiri.address) 输出 “beijing”
*/
```



### 8.  写出下列代码执行结果并解释原因

> **在函数表达式中内部的函数名，只在该函数内部有效，因此在函数外部该函数名的标识符是不存在的；**

```javascript
var foo = function bar() {
  return 12;
};

console.log(typeof bar);  // "undefined" (不报错，因为typeof安全)
console.log(typeof bar()); // Uncaught ReferenceError: bar is not defined
console.log(typeof foo()); // 正确输出："number"

/**
* 解释：
* var foo = function bar() { ... } 是一个函数表达式，function bar() {...} 是赋值给变量 foo 的值;
* 在函数表达式中，bar作为函数名，只在该函数内部有效，因此在函数外部 bar 标识符是不存在的；
* 所以我们在 foo 外部使用 bar 标识符会抛出错误 Uncaught ReferenceError: bar is not defined
*/
```



### 9.  写出下列代码执行结果并解释原因

> 考察：原型、原型链

```javascript
function f() {
  return f;
}
console.log(new f() instanceof f); // false

/**
* 解释：
* f 是一个构造函数，他的原型指向 f.prototype
* 而 f 返回函数本身，通过 new f() 会得到一个空对象，而该对象就是函数 f 本身；
* 本例中表达式为：f instanceof f --> 左操作数：f（函数对象）/ 右操作数：f（构造函数）
* a instanceof b 会判断 b 是否在 a 的原型链上，
* 对于 new f(): f.__proto__ → Function.prototype → Object.prototype
* 对于 f: f.prototype
* 因此 new f() instanceof f 的结果为 false
*/
```



### 10. 手写代码实现`kuai-shou-front-end => KuaiShouFrontEnd`

```javascript
function kebabToPascal(str) {
  // 使用空格替换所有连字符，并分割为单词数组
  const words = str.replace(/-/g, ' ').split(' ');
  
  // 过滤空值并转换每个单词
  return words
    .filter(word => word.length > 0)
    .map(word => 
      // 取首字母大写 + 剩余字母小写
      word.charAt(0).toUpperCase() + word.substring(1).toLowerCase()
    )
    .join(''); // 拼接所有单词
}

// 测试用例
console.log(kebabToPascal("kuai-shou-front-end")); // KuaiShouFrontEnd
console.log(kebabToPascal("hello-world"));         // HelloWorld
console.log(kebabToPascal("a-b-c"));               // ABC
console.log(kebabToPascal("--test-case--"));       // TestCase
```



### 11. 格式化文件大小

```javascript
const formatFileSize = (bytes) => {
  // 函数接收一个数字参数 "bytes"，表示文件大小的字节数
  if (bytes === 0) return "0 B"; // 如果字节数为0，直接返回 "0 B"
  
  const k = 1024; // 定义单位换算基准，1KB=1024字节
  const sizes = ["B", "KB", "MB", "GB", "TB"]; // 定义单位名称数组
  
  // 计算应该使用哪个单位：
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  // 使用对数运算确定文件大小对应的单位索引
  // 相当于计算：bytes 是 1024 的几次方
  
  // 计算结果值并格式化：
  return (bytes / Math.pow(k, i)).toFixed(2) + " " + sizes[i];
  // 1. 将字节数除以对应单位的换算系数（1024^i）
  // 2. 用 toFixed(2) 保留两位小数
  // 3. 拼接上对应的单位字符串
};
```



### 12. 文件切片上传

#### 12. 1 文件切片

通过 **File.prototype.slice** 按照固定大小进行分割

```javascript
createFileChunk = (file, size) => {
  // 用于存储文件切片
  const fileChunkList = []
  // 当前处理到的位置
  let cur = 0
  // 每一块的标识
  let index = 0
  while (cur < file.size) {
    fileChunkList.push({
        flag: index,
        file: file.slice(cur, cur + size)
    })
    cur += size
    index++
  }
  return chunkList
}
```

#### 12.2 计算 hash 作为唯一标识

##### 12.2.1 文件唯一标识

通过 `spark-md5` 库对文件进行加密生成唯一标识

```javascript
function getFileHash(chunks) {
  return new Promise((resolve, reject) => {
    const spark = new SparkMD5()
    function _readFile(i) {
      if (i >= chunks.length) {
        resolve(spark.end())
        return
      }
      const { file } = chunks[i]
      const reader = new FileReader()
      reader.onload = (e) => {
        const bytes = e.target.result
        spark.append(bytes)
        _readFile(i + 1)
      }
      reader.readAsArrayBuffer(file)
    }
    _readFile(0)
  })
}

```

##### 12.2.2 标识切片后的每个chunk：每项的`flag`修改为`${hash}_${flag}`即可完成标识

#### 12.3 文件上传

- 每个切片创建一个**`FormData`对象**
- 使用 **`Promise.race`** 控制**并发**上传数量

#### 12.4 断点续传

- **验证切片是否存在**：在上传每个切片之前，可以先向服务器发送一个**请求来验证该切片是否已存在**

- **重试机制**：如果某个切片的上传失败则重新上传该切片

```javascript
async function uploadChunk(chunk, fileKey, index, retries = 3) {  
    try {  
        const formData = new FormData();  
        formData.append('file', chunk);  
        formData.append('index', index);  
        formData.append('fileKey', fileKey);  
  
        await axios.post('/upload', formData, {  
            headers: {  
                'Content-Type': 'multipart/form-data'  
            }  
        });  
    } catch (error) {  
        if (retries > 0) {  
            console.log(`Failed to upload chunk ${index + 1}, retrying...`);  
            // 等待一段时间后重试  
            await new Promise(resolve => setTimeout(resolve, 1000)); // 等待1秒  
            // 递归调用，减少重试次数  
            await uploadChunk(chunk, fileKey, index, retries - 1);  
        } else {  
            console.error(`Failed to upload chunk ${index + 1} after ${retries} retries.`);  
            // 可以选择抛出错误或进行其他错误处理  
        }  
    }  
}  
  
// 调用函数上传切片  
uploadChunk(chunks[i], fileKey, i);
```



### 13. 手写 `ES6 Proxy` 如何实现 arr[-1] 的访问

#### 13.1 Proxy 的使用：

##### 13.1.1 创建代理

- **`target`**: 被代理的目标对象（可以是任何类型）
- **`handler`**: 包含拦截操作（traps）的对象，定义代理行为

```javascript
const proxy = new Proxy(target, handler);
```

##### 13.1.2 **`get`：拦截属性读取**

|    参数    |     类型      |                         说明                          |
| :--------: | :-----------: | :---------------------------------------------------: |
|  `target`  |    Object     |                   被代理的目标对象                    |
| `property` | String/Symbol |                    被访问的属性名                     |
| `receiver` | Object (可选) | 最初触发该访问的对象（通常是 proxy 本身或其继承对象） |

```javascript
get(target, property, receiver) {  }
```

##### 13.1.3 **`set`：拦截属性赋值**

|    参数    |     类型      |          说明          |
| :--------: | :-----------: | :--------------------: |
|  `target`  |    Object     |    被代理的目标对象    |
| `property` | String/Symbol |     被设置的属性名     |
|  `value`   |      Any      |      待设置的新值      |
| `receiver` | Object (可选) | 最初触发设置操作的对象 |

```javascript
set(target, property, receiver) {  }
```

#### 13.2 手写代码：

```javascript
const proxyArray = (arr) => {
    return new Proxy(arr, {
        // target 是我们接收的数组 arr
        get(target, key) {
            // 1. 处理符号属性如 length/map --> arr.length 等价于 arr['length']
            if (typeof key !== "string") return target[key];
            
            // 2. 转换数字索引并处理负值
            const numKey = Number(key);
            if (!isNaN(numKey)) {
                // 处理负索引：-1 → 最后一位
                const validIndex = numKey < 0 
                    ? target.length + numKey 
                    : numKey;
                    
                return target[validIndex];
            }
            
            // 3. 非数字键直接访问（如 length）
            return target[key];
        }
    });
}

var a = proxyArray([1,2,3,4,5,6,7,8,9]);
console.log(a[1]);      //2
console.log(a[-10]);    //9
```



### 14. 我们有两幅扑克牌，从中抽取五张，判断这五张牌是否为顺子，有以下要求

#### 14.1 'A' 看做1，'J' 看做 11，'Q' 看做12，'K' 看做13

#### 14.2 大、小王视为 0，0可以看作任意牌

#### 14.3 如果给出的五张牌能组成顺子就输出true，否则就输出false

#### 14.4 数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]

```javascript
// 示例
输入：[6,0,2,0,4]
返回值：true

输入：[1,0,0,1,0]
返回值：false
```
