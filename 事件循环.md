### 1. 浏览器的进程模型

##### 1.1 进程：应用的==独立内存空间==（不同的进程内存空间相互独立互不干扰）

##### 1.2 线程：用于运行代码，一个进程最少包含一个线程（主线程），一个进程可以启动多个线程

##### 1.3 浏览器进程：

- 浏览器进程：负责界面显示、用户交互...
- 网络进程：负责加载网络资源
- 渲染进程：开启**==渲染主线程==**，**执行`HTML、CSS、JS` 代码**，**一个标签页一个渲染进程**，防止某个标签页崩溃导致
- ......



### 2. 渲染主线程

##### 2.1 渲染主线程的任务：

- 解析 `HTML`
- 解析 `CSS`
- 计算样式
- 布局
- 处理图层
- 每秒把页面画 60 次
- 执行全局 `JS` 代码
- 执行事件处理函数
- 执行计时器的回调函数

##### 2.2 **渲染主线程**如何**调度不同的任务**？

- 在最开始的时候，渲染主线程会进入一个**无限循环**

- 每一次循环会**检查消息队列中是否有任务**存在。如果有，就**取出第一个任务执行**，执行完一个后进入下一次循环；如果没有，则进入休眠状态。

- 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务

![image-20260209142215439](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260209142215439.png)



### 3. 异步

##### 3.1 什么是异步

代码在执行过程中，会遇到一些无法立即处理的任务，比如：

- 计时完成后需要执行的任务  --  `setTimeout`、`setInterval`

- 网络通信完成后需要执行的任务  --  `XHR`、`Fetch`

- 用户操作后需要执行的任务  --  `addEventListener`


如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」

![image-20260209143443377](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260209143443377.png)

![image-20260209143506583](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260209143506583.png)

##### 3.2 如何理解异步

`JavaScript` 是一门**单线程**的语言，这是因为它运行在浏览器的渲染主线程中，而**渲染主线程只有一个**。

而**渲染主线程承担着诸多的工作**，渲染页面、执行 `JS` 都在其中运行。

**如果使用同步的方式，就极有可能导致主线程产生==阻塞==**，从而导致消息队列中的很多其他任务无法得到执行。这样一来，**一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新**，给用户造成卡死现象。

所以**浏览器采用异步的方式来避免==阻塞==**。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而**最大限度的保证了单线程的流畅运行**。


> 逻辑链路：
>
> 1. 单线程 --> 为什么是单线程 --> 只有**一个渲染主线程**
> 2. 同步和异步的差别 --> 同步会**阻塞**，异步用来**避免阻塞**
> 3. 异步的优势 --> 最大限度的保证了**单线程的流畅运行**

##### 3.3 为什么`JS`会阻塞渲染？

**因为==浏览器的渲染==和==`JS`代码的执行==都在==渲染主线程中完成==**

```javascript
<h1>Hello World!</h1>
<button>change</button>
<script>
  var h1 = document.querySelector('h1');
  var btn = document.querySelector('button');
 
  // 死循环指定的时间
  function delay(duration) {
    var start = Date.now();
    while (Date.now() - start < duration) {}
  }
 
  btn.onclick = function () {
    h1.textContent = 'HELLO WORLD!' // 产生新的绘制任务，加入到消息队列
    delay(3000) // 渲染主线程停滞 3s  
  };
</script>
```



### 4. 任务优先级

- **任务没有优先级** -- 先进先出
- ==**消息队列存在优先级**==
  
  - **延时队列**：存放计时器完成后的回调，优先级「中」
  - **交互队列**：存放**用户操作**后产生的事件，优先级「高」 
  - **微队列**：存放需要最快执行的任务**`（Promise，MutationObserver）`**，优先级「最高」
  
  > 在遇到事件循环的面试题时，可以画图来判断

![image-20260213155220689](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260213155220689.png)

##### 4.1 `JS` 中的计时器能精准计时吗？

 `JS` 中的计时器**==无法做到精准计时==**，因为

- **计算器硬件内部没有原子钟**，无法做到精确计时
- 操作系统的计时函数本身就存在偏差，而 **`JS` 计时器最终调用的还是操作系统的计时函数**，所以本身就 继承了这种偏差
- **按照 `W3C` 的标准，若计时器的嵌套层级超过了 5 层，则会带来 `4ms` 的计时偏差**
- 计时器的精确性还**受到事件循环的影响**，计时器的回调函数只能在主线程空闲时执行，因此又带来了偏差

##### 4.2 什么是 `JS` 事件循环

- 事件循环的本质是一个**不会结束的 for 循环**，**每次从消息队列中取出一个任务执行**，而其他线程只需要在合适的时候**将任务加入到任务队列末尾**即可。

- 根据 `W3C` 的解释，每种任务有不同的类型，相同类型的任务必须存放在同一个队列中。而**不同的任务队列存在不同的优先级**，**==优先级高的队列中的任务会优先执行==**，在每次的事件循环中，**==由浏览器自行决定调用哪个队列中的任务执行==**，但**浏览器必须拥有一个微队列**，并且**微队列中的任务具有最高的优先级**，会优先调用。

![image-20260213161317929](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260213161317929.png)