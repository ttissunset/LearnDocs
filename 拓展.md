### 1. PWA 渐进式 Web 应用

#### 1.1 本质与定义

`PWA` 是**通过现代 Web 技术构建的应用程序**，保留 Web 的跨平台性和可链接性的同时提供**类原生应用体验**

- **渐进增强**： 在所有浏览器中基础功能可用，现代浏览器中体验增强
- **离线能力**： 通过 Service Worker 实现无网络访问
- **可安装性**： 可添加至设备主屏幕，独立窗口运行
- **响应式设计**： 自适应不同屏幕尺寸
- **网络无关性**： 在弱网或离线状态下仍可用

#### 1.2 核心技术

##### 1.2.1 **Service Worker**：独立的 JavaScript 线程，充当**网络代理**和**缓存管理器**

> 给网页 `index.html` 注册这么一个 `Service Worker`，它将劫持由 `index.html` 发起的一切 HTTP 请求

-  **离线缓存**：网络无法访问时，拦截请求并返回缓存内容（`fetch` 事件）
-  **后台同步**：网络恢复后自动同步数据（`sync` 事件）
-  **推送通知**：通过 `Push API` 发送离线通知

##### 1.2.2 Web App Manifest：`JSON` 文件定义**安装行为**和**系统集成**

```javascript
{
  "name": "My PWA",
  "short_name": "App",
  "icons": [{ "src": "/icon-192.png", "sizes": "192x192" }],
  "start_url": "/index.html",
  "display": "standalone", // 全屏模式
  "background_color": "#fff",
  "theme_color": "#3367D6"
}
```

##### 1.2.3 HTTPS 协议：提供安全性保障，防止中间人攻击篡改 Service Worker



### 3. MVVM 模式

#### 3.1 定义

MVVM 全称  **`Model-View-ViewModel`**  ，将数据、业务逻辑和用户界面分离:

- **视图 `View`**：用于**封装 UI 和 UI 逻辑**
- **视图模型 `ViewModel`**：用于封装表示逻辑和状态，并作为**连接视图`View`和模型`Model`的桥梁**。`ViewModel`可以取出`Model`的数据，同时处理 `View` 中需要展示内容而涉及的业务逻辑
- **模型 `Model`**：用于封装应用的**业务逻辑和数据**

| 角色      | 含义     | Vue 中的体现                         |
| --------- | -------- | ------------------------------------ |
| Model     | 数据层   | `data, computed, prop`s 等           |
| View      | 视图层   | 模板（`template`）/ `DOM`            |
| ViewModel | 连接桥梁 | `Vue` 实例，本质是观察者和响应式系统 |

在 MVVM 模式中，各部分之间的**通信是双向的**。视图 `View` 和视图模型 `ViewModel `之间的数据绑定是双向的，**当模型的属性变化时，视图会自动更新；反之当视图中的输入发生变化时，模型的数据也会自动更新**

![img](https://learn.microsoft.com/zh-tw/training/dot-net-maui/design-mvvm-viewmodel/media/mvvm-overview-diagram.png)

#### 3.2 MVVM与传统MVC的区别

| 特性           | MVC                                                          | MVVM                                                         |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **组成结构**   | `Model - View - Controller`                                  | `Model - View - ViewModel`                                   |
| **通信方式**   | 控制器处理用户输入并更新视图或模型；<br>**视图需手动更新，不直接绑定数据** | `ViewModel` 提供数据绑定机制；<br>**视图通过绑定自动同步 `ViewModel` 数据** |
| **双向绑定**   | 不支持，需手动更新 UI 和 Model                               | 支持（`UI` 与 `ViewModel` 自动同步）                         |
| **代码耦合度** | **视图与控制器耦合较高**                                     | **视图与 `ViewModel` 耦合低，易于维护**                      |
| **适用场景**   | `Web` 应用、**传统桌面应用**                                 | 前端框架（`Vue.js, React, WPF）`、<br>需数据驱动的 `UI`      |



### 4. Lighthouse 优化

- **在 `Chrome DevTools` 中运行**

- ##### **使用 `Performance API`**

```javascript
window.addEventListener('load', () => {
  const { loadEventEnd, navigationStart } = performance.timing;
  console.log('页面加载时间:', loadEventEnd - navigationStart, 'ms');
});
```

#### 4.1页面加载性能指标

| 指标                                    | 说明                                             | 重要性 |
| --------------------------------------- | ------------------------------------------------ | ------ |
| **==TTFB==（Time to First Byte）**      | 从用户发起请求到服务器**返回第一字节**的时间     | 🔥🔥🔥    |
| **FCP（First Contentful Paint）**       | 页面**首次渲染**内容出现的时间                   | 🔥🔥     |
| **==LCP==（Largest Contentful Paint）** | 加载**最大可视内容**（如大图片或大段文本）的时间 | 🔥🔥🔥    |
| **==TTI==（Time to Interactive）**      | 页面**可以交互**的时间                           | 🔥🔥🔥    |
| **DOMContentLoaded（DCL）**             | DOM 解析完成的时间                               | 🔥      |
| **Load Time**                           | 页面所有资源加载完成的时间                       | 🔥      |

#### 4.2 交互性能指标

| 指标                               | 说明                                               | 重要性 |
| ---------------------------------- | -------------------------------------------------- | ------ |
| **FID（First Input Delay）**       | 用户首次交互（点击、输入等）与浏览器响应之间的延迟 | 🔥🔥🔥    |
| **CLS（Cumulative Layout Shift）** | 页面布局的视觉稳定性                               | 🔥🔥     |
| **FPS（Frames Per Second）**       | 页面帧率，影响动画流畅度                           | 🔥🔥     |
| **TBT（Total Blocking Time）**     | `JavaScript` 阻塞主线程的时间                      | 🔥🔥🔥    |

#### 4.3 如何提升优化

| 优化措施            | Lighthouse 评分 |
| ------------------- | --------------- |
| 初始页面            | 2 分            |
| 开启文本压缩        | 21 分           |
| 优化图片偏移        | 52 分           |
| 延迟加载 JS 脚本    | 57 分           |
| 减少 JS 执行时间    | 86 分           |
| 分包和提取 CSS 文件 | 86 分           |
| 缩减资源体积        | 97 分           |
| 图片优化            | 99 分           |
| 延迟加载 CSS 文件   | 99 分           |



### 5. 前端工程化

#### 5.1 定义

前端工程化是指将前端开发过程中的**一系列流程和工具进行规范和自动化**，从而提高开发效率、减少重复劳动、降低出错率。**前端工程化的目标是让前端开发更高效、更优质**。

#### 5.2 核心概念

##### 5.2.1 模块化

**模块化是指将一个大的应用程序划分成多个小的模块**，每个模块都有自己的功能和特点，可以独立开发、测试和维护。常见的模块化方案有 CommonJS、ES6 模块、AMD 等。

##### 5.2.2 打包构建

**打包构建是指将多个模块组合起来，生成可以在浏览器中运行的代码**。打包构建的过程包括代码压缩、文件合并、资源管理等，常见的打包构建工具有 `webpack、rollup、vite`等。

#####  5.2.3 自动化部署

自动化部署是指将**打包构建后的代码部署到生产环境或测试环境中的自动化过程**。自动化部署可以减少手动部署的错误和工作量，同时也可以缩短部署的时间。常见的自动化部署工具有 Jenkins、Drone CI 等。

##### 5.2.4 自动化测试

自动化测试是指**使用自动化工具对代码进行测试**，以确保它们在开发过程中不会出现问题，并且在部署到生产环境之前也不会出现问题，用于提高开发效率和代码质量

- **单元测试**：测试应用程序中**最小的可测试单元**，例如一个函数或一个类
- **端到端测试**：指测试应用程序的**整个流程**，包括用户界面和后端逻辑



### 6. Echarts 怎么用



### 7. 如何通过 `NPM` 发包

##### 7.1 通过 `npm init -y` 初始化项目结构

```javascript
📦 my-package 
┣ 📂 src // src 目录用于存放项目代码
┃ ┗ 📜 index.js
┣ 📂 test // test 目录用于进行单元测试
┃ ┗ 📜 index.test.js
┣ 📜 package.json // 管理包的元数据
┗ 📜 README.md // 包的说明文档
```

> `package.json` 说明:
>
> ```javascript
> {
>   "name": "my-package", // 包的名称
>   "version": "1.0.0", // 包的版本
>   "description": "My awesome package", // 对包的描述
>   "main": "src/index.js", // 入口文件
>   "scripts": { // 一些可供运行的脚本
>     "test": "echo \"Error: no test specified\" && exit 1"
>   },
>   "author": "Your Name", // 作者
>   "license": "MIT" // 开源协议
> }
> ```

##### 7.2 编写包的代码

- 在 `srx` 目录下编写代码文件
- 在`src`目录的 `index.js`文件作为包的入口文件

##### 7.3 切换源为官方源 `npm config set registry=https://registry.npmjs.org`

##### 7.4 通过 `npm login` 登录 `NPM` 用户名、密码和邮箱

##### 7.5 在根目录下执行 `npm publish`  将包发布到 `NPM`

> 注意：包需要分配**唯一的版本号**！！
>
> 可通过 `npm version x.x.x` 自定义包的版本号，也可通过 `npm version major` 递增版本号
>
> 发布前可通过执行 `npm publish --dry-run` 来模拟发布是否存在问题

##### 7.6 通过 `npm install my-package` 将包引入项目中使用



### 8. 封装 `Vue` 的 `NPM` 组件

##### 8.1 初始化 `vue` 项目结构  `npm init vite@latest`

##### 8.2 在 `src` 目录下创建 `packages` 目录用于封装组件和方法

- 创建 `Button` 文件夹用于封装**按钮组件**
- 创建 `public-js` 文件夹用于封装**公用方法**

> 注意：`public-js` 问价架需要通过 `index.js` 导出所有的公用方法供组件使用

##### 8.3 在 `packages` 根目录中编写 `index.js` 入口文件

```javascript
import KiriButton from './Button/index';

// 组件列表
const components = [KiriButton];
// 方法
import publicjs from "../package/public-js/index.js"; // 引入封装好的方法

export { KiriButton };

const install = (app: App) => {
     components.forEach((component) =>
      app.component(component.__name as string, component),
    );
}

export default { install, publicjs };
```

##### 8.4 编写项目的 package.json 文件

- `name`：包名，必须全局唯一，不能与已有包重名。
- `version`：版本号，遵循 semver 规范。
- `main`：入口文件路径（如 dist/index.js）。
- `files`：指定发布到 npm 的文件
- `keywords、description、author` 等信息

```javascript
{
  "name": "vue-kiri-ui",
  "version": "0.2.2",
  "author": "Kiri",
  "description": "组件发布npm练习",
  "files": [
    "dist"
  ],
  "keywords": ["Button", "button"],
  "main": "dist/index.js"
}
```



### 4. ==Webapack==构建工具

#### 4.1 Webpack 基本概念

##### 4.1.1 介绍

- ==在 `webpack` 中一切皆**模块**，如  `css、js` 等==
- 集成了 `Nodejs` 环境（基于 Node 开发）
- 依赖：**`webpack、wbpack-cli`**，通过 `npm webpack` 打包项目
- **Loader**：用于**转换文件**
- **Plugin**：**注入钩子**函数

- **`webpack.config.js`**：`webpack` 配置文件 --> ==注意：`webpack.config.js`需要遵循 `CommonJs` 规范！！！==

#### 4.1 使用 entry 

- `entry`：用于指定打包的入口文件，有三种不同的配置方式

```javascript
// 1. 使用字符串：指定单个入口文件
entry:"./index.js"

// 2. 使用数组形式：将多个入口文件打包为一个文件
entry:['./a.js', './b.js']

// 3. 对象形式：多各不同的入口文件分别打包为对应的文件
entry:{
    a: './a.js',  // 被打包为 a.js
    b: './b.js',  // 被打包为 b.js
}
```

#### 4.2 使用 output

- `output`：用于指定打包的出口，是一个**对象**
  - `filename` 属性：指定打包后的文件名，默认为 `main.js`
    - 如果配置了`entry`打包为多个文件，则需要修改为 `filename：[name].js`
  - `path` 属性：指定打包后的输出路径，默认为  `dist` 目录
  - `clean` 属性：是否自动清理打包目录

```javascript
const path = require('path')

output:{
    // 输出文件名为 'bundle.js'
    filename: 'bundle.js'，
    // 输出路径
    path:path.resolve(__dirname, ',.dist')
}
```

#### 4.3 使用 Loader

- 在 `webpack` 中**==原生只支持解析 `js` 文件==**，因此我们需要通过 `Loader` 来**解析其他类型的文件如 `.css/.vue/.png ...`**
- ==`webpack` 遵循**单一职责**，一个 `loader` 只负责处理一件事==
- 解析 `.css` 所需包： **`style-loader/css-loader`**
- 配置： 

```javascript
module:{
    // rules 用于配置不同的处理方案，每个配置都是一个对象
    rules:[
        {
            // 通过正则表达式去匹配所有的 css 文件
            test: /\.css$/i,
            // 使用 style-loader 和css-loader 进行处理
            // 注意： 必须先 style 才能 css 否则报错！！！
            use:['style-loader', 'css-loader']
        }，
        {
        	test: /\.(png|jpg|jrpg|gif)$/i,
        	// 注意：webpack 原生包含了图片解析的 loader 不需要额外安装，只需要配置 type 即可
        	type:"assets/resource"
        }
    ]
}
```

#### 4.4 使用 Bable

- `Bable` 用于将 ES6+ 的代码转换为低版本代码，用于**处理浏览器兼容问题**
- 注意： ==`Bable` 是 `webpack` 的 `Loader`！！==
- 所需包：`bable-loader @bable/core @bable/preset-env`

```javascript
{
    // 匹配所有以 .js 或者 .mjs 结尾的文件
    test:/\.m?js$/,
    // 排除 node_modules 和  bower_components
    exclude: /(node_modules | bower_components)/,  
    use:{
        // 使用 bable_loader 作为加载器
        loader:"bable_loader",
        options:{
            // 使用 bable 的默认配置(如所需环境等)
            presets:["@bable/preset-env"]
        }
    }
}
```

- ==处理浏览器兼容==：需要配置 `package.json` 文件(可参考[github](https://github.com/browserslist/browserslist))

```javascript
"browserslist": [
    "> 1%", // 代表全球超过1%使用的浏览器
    "last 2 versions", // 所有浏览器兼容到最后两个版本
    "Firefox ESR", // 火狐最新版本
    "Chrome >= 80", // 指定浏览器的版本范围
    "not ie <=8" // 不兼容 ie8 以下的浏览器
  ]
```

#### 4.5 使用 Plugin

- `Plugin` 是用来**扩展 `Webpack` 功能**的如：**代码压缩**、**代码分离**

- 代码压缩插件：`optimize-css-assets-webpack-plugin`
- 代码分离：`mini-css-extract-plugin`、`html-webpack-plugin`
- 配置：

```javascript
// 分离 CSS
const MiniCssExtractplugin = require('mini-css-extract-plugin')
// 压缩 CSS
const OptimizeCSS = require('optimize-css-assets-webpack-plugin')
// 分离 HTML 实现自动引用 
const HTMLPLugin = require('html-webpack-plugin')

plugins:[
    // 分离 CSS
    new MiniCssExtractplugin({
		// 打包后的
        filename:'main.css'
    })，
    // 压缩 CSS
    new OptimizeCSS()，
    // 分离 HTML：在出口文件夹下自动生成 index.html文件
    new HTMLPLugin({
        // 指定 index.html 的标题
        title:"hello world"
        // 参考模板的文件路径
        template: './public/index.html'
    })
]

// 注意：使用 'mini-css-extract-plugin' 后需要修改 rules
module:{
    // rules 用于配置不同的处理方案，如 css js es6 等
    rules:[
        {
            // 通过正则表达式去匹配所有的 css 文件
            test: /\.css$/,
            // 
            use:[{
                loader: MiniCssExtractplugin.loader
            },
                "css-loader"
            ]
        }
    ]
}
```

#### 4.5 使用 DevServer

- `DevServer` 创建**开发服务器**使得我们能够以**服务器**的方式运行网页
- `webpack` 基于 **`WebSocket` 协议**自动刷新网页实现实时预览

- 依赖：`webpack-dev-server`
- 配置：

```javascript
devServer:{
	// 服务器打开目录
	contentBase: path.join(__dirname, 'dist'),
	// 是否进行压缩
	compress: true,
    // 运行端口
	port: 8080,
    // 是否热更新
	hot: true,
    // 是否在服务器启动后自动打开浏览器 
	open: true
}
```

- 修改 `package.json`

```javascript
”scripts“：{
    "dev": "webpack-dev-server "
}
```

#### 4.6 webpack 构建优化

##### 4.6.1 优化构建速度

- 

##### 4.6.2 优化输出质量 -- 压缩文件体积

- 压缩不同的文件资源

  - 压缩 `js`：使用 `terser-webpack-plugin` 压缩
  - 压缩 css：使用 `opimize-css-assets-webpack-plugin` 压缩

  ```javascript
  new OptimizeCssAssetsPlugin({
    assetNameRegExp: /\.optimize\.css$/g,
    cssProcessor: require('cssnano'),
    cssProcessorPluginOptions: {
      preset: ['default', { discardComments: { removeAll: true } }],
      //autoprefixer: { browsers: CSS_BROWSERS }, 也是可以指定前缀的
    },
    canPrint: true
  })
  ```

  - 压缩图片：使用 `image-webpack-loader` 压缩
  - gzip 压缩：使用 `compression-webpack-plugin` 压缩

- 通过 `Tree Shaking` 剔除无用 `js` 代码

​	
