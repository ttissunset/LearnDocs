## 浏览器渲染原理

> 浏览器按下回车 = 网络 + 渲染

> 1. 网络线程获取 HTML 文档生成**渲染任务**，传递给**渲染主线程**的消息队列
> 2. 在**事件循环**中，渲染主线程获取渲染任务进行渲染
>
> ![image-20260129144145254](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129144145254.png)



### 渲染流水线

- **解析HTML**
- **样式计算**
- **布局**
- **分层**
- **绘制**
- **分块**
- **光栅化**
- **画图**



### 1. 解析HTML - Parse HTML

- #### 生成 `DOM` 树和 `CSSOM` 树

![image-20260129144551723](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129144551723.png)

- #### 解析 `CSS` 生成 `StyleSheetList` 数组，即 `CSSOM：Css Object Model`

> 样式表：
>
> - ```<style></style>```
> - ``` <link > ``` 内联样式
> - ``` <div style="...">``` 行内样式
> - 浏览器默认样式
>
> 每一个样式表都会生成一个 `CSStyleSheet` 节点
>
> ![image-20260129150634454](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129150634454.png)

![image-20260129144902486](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129144902486.png)

- #### 在解析 HTML 中遇到 `CSS` 的处理

  - 浏览器启动**预解析线程** --> 提高解析效率
  - 预解析线程通过网络线程获取 `CSS` 文件并解析 `CSS` --> **`CSS` 不会阻塞渲染主线程的原因！！**
  - 预解析线程将解析结果交给**渲染主线程生成 `CSSOM` 树**

![image-20260129150820733](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129150820733.png)

- #### 在解析 HTML 中遇到 `JS` 的处理

  - 渲染主线程遇到 `JS` 时必须**暂停一切解析行为**，等待 `JS` 下载执行完毕后才能继续

  > 原因：**`JS` 代码可能会修改当前生成的 DOM 树** ，这就是 `JS` 执行会阻塞 `HTML` 解析的根本原因

  - 预解析线程可以分担一点 `JS` 的任务

![image-20260129151443069](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129151443069.png)



### 2. 样式计算 - Recalculate Style

> 1. `CSS` 属性的计算过程
> 2. 视觉格式化模型

- 生成每个结点的**最终样式** `Computed Style` --> **确保当前元素的所有 `CSS` 属性都有值**

![image-20260129152105698](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129152105698.png)

<img src="https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129152450506.png" alt="image-20260129152450506" style="zoom: 80%;" />





### 3. 布局 - Layout

- **根据样式算出每个节点的尺寸与位置**得到 `Layout` 树

> 尺寸：宽度、高度
>
> 位置：相对于**包含块**的位置

- **两个注意点**

  - 并非所有样式都能在样式计算中得到结果，如：`width: 100%、margin: auto`
  - `Layout` 树并非与 `CSSOM` 树一一对应

  > 原因：隐藏的元素`（如设置display :none）`不会出现在布局树中，而通过 `::before、::after` 伪元素生成的内容会出现在 `Layout` 树中
  >
  > - 内容必须在行盒中 --> 即使是 `p` 标签中的内容，会默认生成一个**匿名行盒**来包裹内容
  > - 行盒和块盒不能相邻 --> 如果两个块级元素中夹着一个行盒，则会默认生成**匿名块盒**来包裹内容
  >
  > ![image-20260129153705215](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129153705215.png)

![image-20260129152711508](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129152711508.png)

### 4. 分层 - Layer

- 跟**堆叠上下文**有关的属性（如：`z-index、opacity、transform`）会影响分层结果
- 可以通过 `will-change` 属性影响分层的结果

![image-20260129154601487](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129154601487.png)

### 5. 绘制 - Paint

- 生成一条条**绘制指令**交给渲染主线程
- 分层的**每一个层都会生成绘制指令集**

![image-20260129155906836](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129155906836.png)

- 绘制是**渲染主线层**参与的**最后一个步骤**

![image-20260129155920816](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129155920816.png)

### 6.分块 - Tilling

![image-20260129160202296](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129160202296.png)

- 渲染主线程将各个图层的绘制信息交给合成线程
- **合成线程**将每一个图层划分为若干小区域

![image-20260129160216035](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129160216035.png)

### 7. 光栅化 - Raster

- 合成线程会将块信息交给 `GPU` 进程 --> **光栅化在 `GPU` 进程中进行**
- 将分块变成**位图** --> 包含像素点的信息
- 优先处理靠近视口的分块

![image-20260129163414622](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129163414622.png)

### 8. 画 - Draw

- `GPU` 得到每个块的位图后，会生成 `quad` 指引细腻系，标识每个位图应该画到屏幕的哪个位置，以及会**考虑到变形和缩放**
- ==**变形（transform）不会改变元素的布局信息，**它只是在渲染的**最终阶段**对元素的视觉输出进行变形，**发生在合成线程而不是渲染主线程**！因此使用 transform 的效率高！==

![image-20260129163453061](https://gitee.com/phenylaminopropionic-acid/photo/raw/master/sunbox/image-20260129163453061.png)

### 9. 回流 - `Reflow`

- `reflow`  的本质是在进行**影响布局**的操作后（如：修改宽高，修改 `margin、padding`等），**重新计算 `layout` 树**
- **为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 `JS` 代码全部执行完后再进行统一计算。因此，改动属性造成的 ==Reflow 是异步的==！**
- 由于 `layout` 分层在渲染的前几步，而 `layout` 树的改变会导致后续所有的渲染步骤重新进行因此 `reflow` 的开销极大



### 10. 重绘 - Repaint

- `repaint` 的本质是在改动**可见样式**后，重新根据分层信息计算绘制指令
- 由于布局信息也属于可见样式，因此**`Reflow` 一定会导致 Repaint**
